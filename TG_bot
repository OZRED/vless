import asyncio
import os
import re
import configparser
import ipaddress
import subprocess
import base64
import requests
from aiogram import F
from urllib.parse import urlparse, parse_qs, unquote
from collections import Counter

from aiogram import Bot, Dispatcher, types, F
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, FSInputFile
from aiogram.filters import Command

# ================= –ù–ê–°–¢–†–û–ô–ö–ò =================

BOT_TOKEN = ""
GITHUB_TOKEN = ""
ADMIN_IDS = []

REPO = "OZRED/vless"
REPO_FILE = "SuicideEtoExit"

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

FILES = {
    "sites": "site.txt",
    "vless": "vless_list.txt",
    "white": "ipwhitelist.txt",
    "bad": "bad-ipwhitelist.txt",
    "settings": "settings.ini"
}

SITES_PER_PAGE = 5

# ================ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ================

bot = Bot(BOT_TOKEN)
dp = Dispatcher()

# ================ –ù–ê–°–¢–†–û–ô–ö–ò –§–ê–ô–õ–ê ================

def load_settings():
    config = configparser.ConfigParser()
    config.read(FILES["settings"])
    if "SETTINGS" not in config:
        config["SETTINGS"] = {
            "remove_duplicates": "True",
            "use_whitelist": "False",
            "rename_keys": "True",
            "geo_attempts": "1",
            "geo_step": "20"
        }
        with open(FILES["settings"], "w") as f:
            config.write(f)
    return config

def save_settings(config):
    with open(FILES["settings"], "w") as f:
        config.write(f)

# ================ –£–¢–ò–õ–ò–¢–´ ================

def is_admin(user_id):
    return user_id in ADMIN_IDS

def read_lines(file):
    if not os.path.exists(file):
        return []
    with open(file, "r", encoding="utf-8", errors="ignore") as f:
        return [x.strip() for x in f if x.strip()]

def write_lines(file, lines):
    with open(file, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

def extract_host_port_sni(link):
    try:
        parsed = urlparse(link)
        host = parsed.hostname
        port = parsed.port
        q = parse_qs(parsed.query)
        sni = q.get("sni", [""])[0]
        return f"{host}:{port}:{sni}"
    except:
        return None

def host_is_ip(host):
    try:
        ipaddress.ip_address(host)
        return True
    except:
        return False

def get_flag(text):
    m = re.search(r'[\U0001F1E6-\U0001F1FF]{2}', text)
    return m.group(0) if m else "üåê"

# ================= –°–ª–æ–≤–∞—Ä—å —Å—Ç—Ä–∞–Ω =================
def country_name_from_flag(flag):
    mapping = {
        # –ï–≤—Ä–æ–ø–∞
        "üá∑üá∫": "–†–æ—Å—Å–∏—è",
        "üá≥üá±": "–ù–∏–¥–µ—Ä–ª–∞–Ω–¥—ã",
        "üá©üá™": "–ì–µ—Ä–º–∞–Ω–∏—è",
        "üá´üáÆ": "–§–∏–Ω–ª—è–Ω–¥–∏—è",
        "üáµüá±": "–ü–æ–ª—å—à–∞",
        "üá±üáª": "–õ–∞—Ç–≤–∏—è",
        "üá´üá∑": "–§—Ä–∞–Ω—Ü–∏—è",
        "üá™üá™": "–≠—Å—Ç–æ–Ω–∏—è",
        "üá∏üá™": "–®–≤–µ—Ü–∏—è",
        "üáπüá∑": "–¢—É—Ä—Ü–∏—è",
        "üá¶üá±": "–ê–ª–±–∞–Ω–∏—è",
        "üá±üáπ": "–õ–∏—Ç–≤–∞",
        "üá™üá∏": "–ò—Å–ø–∞–Ω–∏—è",
        "üá®üá≠": "–®–≤–µ–π—Ü–∞—Ä–∏—è",
        "üá¶üáπ": "–ê–≤—Å—Ç—Ä–∏—è",
        "üá≤üá©": "–ú–æ–ª–¥–∞–≤–∏—è",
        "üá≠üá∫": "–í–µ–Ω–≥—Ä–∏—è",
        "üáÆüáπ": "–ò—Ç–∞–ª–∏—è",
        "üáßüáæ": "–ë–µ–ª–∞—Ä—É—Å—å",
        "üá®üáø": "–ß–µ—Ö–∏—è",
        "üáÆüá™": "–ò—Ä–ª–∞–Ω–¥–∏—è",
        "üá¨üáß": "–í–µ–ª–∏–∫–æ–±—Ä–∏—Ç–∞–Ω–∏—è",
        "üá¨üá∑": "–ì—Ä–µ—Ü–∏—è",
        "üáÆüá∏": "–ò—Å–ª–∞–Ω–¥–∏—è",
        "üá±üá∫": "–õ—é–∫—Å–µ–º–±—É—Ä–≥",
        "üá≥üá¥": "–ù–æ—Ä–≤–µ–≥–∏—è",
        "üá≤üá∞": "–°–µ–≤–µ—Ä–Ω–∞—è –ú–∞–∫–µ–¥–æ–Ω–∏—è",
        "üá≠üá∑": "–•–æ—Ä–≤–∞—Ç–∏—è",
        "üá∑üá¥": "–†—É–º—ã–Ω–∏—è",
        "üáßüá™": "–ë–µ–ª—å–≥–∏—è",
        "üáßüá¶": "–ë–æ—Å–Ω–∏—è –∏ –ì–µ—Ä—Ü–µ–≥–æ–≤–∏–Ω–∞",
        "üá∏üá∞": "–°–ª–æ–≤–∞–∫–∏—è",
        "üá≤üáπ": "–ú–∞–ª—å—Ç–∞",
        "üáßüá¨": "–ë–æ–ª–≥–∞—Ä–∏—è",
        "üá¨üá™": "–ì—Ä—É–∑–∏—è",
        "üáÆüá±": "–ò–∑—Ä–∞–∏–ª—å",
        
        # –ê–º–µ—Ä–∏–∫–∞
        "üá∫üá∏": "–°–®–ê",
        "üá®üá¶": "–ö–∞–Ω–∞–¥–∞",
        "üáßüá∑": "–ë—Ä–∞–∑–∏–ª–∏—è",
        "üá¶üá∑": "–ê—Ä–≥–µ–Ω—Ç–∏–Ω–∞",
        
        # –ê–∑–∏—è
        "üáÆüá≥": "–ò–Ω–¥–∏—è",
        "üáÆüá∑": "–ò—Ä–∞–Ω",
        "üáØüáµ": "–Ø–ø–æ–Ω–∏—è",
        "üá∞üáø": "–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω",
        "üá∏üá¨": "–°–∏–Ω–≥–∞–ø—É—Ä",
        "üáªüá≥": "–í—å–µ—Ç–Ω–∞–º",
        "üá¶üá™": "–û–ê–≠",
        "üá≠üá∞": "–ì–æ–Ω–∫–æ–Ω–≥",
        "üá∞üá∑": "–Æ–∂–Ω–∞—è –ö–æ—Ä–µ—è",
        "üá≤üáæ": "–ú–∞–ª–∞–π–∑–∏—è",
        "üá¶üá≤": "–ê—Ä–º–µ–Ω–∏—è",
        
        # –û–∫–µ–∞–Ω–∏—è
        "üá¶üá∫": "–ê–≤—Å—Ç—Ä–∞–ª–∏—è",
        "üá≥üáø": "–ù–æ–≤–∞—è –ó–µ–ª–∞–Ω–¥–∏—è",
        
        # —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥
        "üåê": "Unknown",
        "üá®üá≥": "–ö–∏—Ç–∞–π",
        "üá∫üá≤": "–°–®–ê (–ú–∞—Ä—à–∞–ª–ª–æ–≤—ã –æ—Å—Ç—Ä–æ–≤–∞ –∏–ª–∏ –¥—Ä.)"  # —Ä–µ–¥–∫–∏–π —Ñ–ª–∞–≥
    }
    return mapping.get(flag, "Unknown")

# ================= –ö–õ–ê–í–ò–ê–¢–£–†–´ =================

def main_menu():
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üì• –°–±–æ—Ä –∫–ª—é—á–µ–π", callback_data="collect")],
        [InlineKeyboardButton(text="üßπ –û–±—Ä–∞–±–æ—Ç–∞—Ç—å", callback_data="process")],
        [InlineKeyboardButton(text="üåç GEO —á–µ–∫", callback_data="geo")],
        [InlineKeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="stats")],
        [InlineKeyboardButton(text="üìÅ –û–±—Ä–∞–±–æ—Ç–∫–∞ vless_list", callback_data="vlessmenu")],
        [InlineKeyboardButton(text="üìÑ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∞–π—Ç–∞–º–∏", callback_data="sites")],
        [InlineKeyboardButton(text="‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="settings")],
        [InlineKeyboardButton(text="üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –±–æ—Ç–∞", callback_data="restart")]
    ])
    return kb

def sites_keyboard(page=0):
    sites = read_lines(FILES["sites"])
    start = page * SITES_PER_PAGE
    end = start + SITES_PER_PAGE
    chunk = sites[start:end]

    kb = []
    for i, s in enumerate(chunk):
        index = start + i  # —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å —Å–∞–π—Ç–∞ –≤ –æ–±—â–µ–º —Å–ø–∏—Å–∫–µ
        kb.append([
            InlineKeyboardButton(text=s[:40], callback_data="noop"),  # –∫–Ω–æ–ø–∫–∞ –¥–ª—è –ø–æ–∫–∞–∑–∞ URL
            InlineKeyboardButton(text="‚ùå", callback_data=f"delsite|{index}")  # –±–µ–∑–æ–ø–∞—Å–Ω—ã–π callback_data
        ])

    # –Ω–∞–≤–∏–≥–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º
    nav = []
    if page > 0:
        nav.append(InlineKeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥", callback_data=f"sites_page|{page-1}"))
    if end < len(sites):
        nav.append(InlineKeyboardButton(text="‚û° –°–ª–µ–¥—É—é—â–∞—è", callback_data=f"sites_page|{page+1}"))
    if nav:
        kb.append(nav)

    # –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∞–π—Ç–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç –≤ –º–µ–Ω—é
    kb.append([InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç", callback_data="add_site")])
    kb.append([InlineKeyboardButton(text="‚¨Ö –í –º–µ–Ω—é", callback_data="back")])

    return InlineKeyboardMarkup(inline_keyboard=kb)


def settings_keyboard():
    s = load_settings()["SETTINGS"]
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"üßπ –î—É–±–ª–∏: {s.get('remove_duplicates','True')}", callback_data="set|remove_duplicates")],
        [InlineKeyboardButton(text=f"üìã Whitelist: {s.get('use_whitelist','False')}", callback_data="set|use_whitelist")],
        [InlineKeyboardButton(text=f"‚úè –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞—Ç—å: {s.get('rename_keys','True')}", callback_data="set|rename_keys")],
        [InlineKeyboardButton(text=f"üåç GEO —à–∞–≥: {s.get('geo_step','20')}", callback_data="set_geo_step")],
        [InlineKeyboardButton(text=f"üîÅ GEO –ø–æ–≤—Ç–æ—Ä–æ–≤: {s.get('geo_attempts','1')}", callback_data="set_geo_attempts")],
        [InlineKeyboardButton(text="‚¨Ö –í –º–µ–Ω—é", callback_data="back")]
    ])
    return kb

# ================ /menu ================

@dp.message(Command("menu"))
async def menu(msg: types.Message):
    if not is_admin(msg.from_user.id):
        return
    await msg.answer("‚ôªÔ∏è VLESS bot by ozred v0.5 üè¥‚Äç‚ò†Ô∏è ", reply_markup=main_menu())

async def send_menu_on_startup():
    for admin_id in ADMIN_IDS:
        try:
            await bot.send_message(admin_id, "‚ôªÔ∏è VLESS bot by ozred v0.5 üè¥‚Äç‚ò†Ô∏è ", reply_markup=main_menu())
        except:
            pass

# ================ –°–ë–û–† –ö–õ–Æ–ß–ï–ô =================

@dp.callback_query(F.data == "collect")
async def collect_keys(cb: types.CallbackQuery):
    config = load_settings()["SETTINGS"]
    remove_duplicates = config.getboolean("remove_duplicates")

    msg = await cb.message.answer("üì• –°–±–æ—Ä –∫–ª—é—á–µ–π –Ω–∞—á–∞—Ç...\n")
    sites = read_lines(FILES["sites"])
    all_links = []
    log = "üì• –°–±–æ—Ä –∫–ª—é—á–µ–π\n\n"

    for i, site in enumerate(sites, 1):
        try:
            r = requests.get(site, timeout=10)
            links = re.findall(r"(?:vless|trojan|ss)://[^\s\"']+", r.text)
            all_links.extend(links)
            log += f"{i}/{len(sites)} {site}\n{len(links)} –∫–ª—é—á–µ–π\n\n"
            await msg.edit_text(log)
        except:
            log += f"{i}/{len(sites)} {site} –û–®–ò–ë–ö–ê\n"
            await msg.edit_text(log)

    before = len(all_links)

    if remove_duplicates:
        uniq = {}
        for l in all_links:
            k = extract_host_port_sni(l)
            if k:
                uniq[k] = l
        all_links = list(uniq.values())

    write_lines(FILES["vless"], all_links)

    log += f"–í—Å–µ–≥–æ: {before}\n–£–¥–∞–ª–µ–Ω–æ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤: {before - len(all_links)}\n–û—Å—Ç–∞–ª–æ—Å—å: {len(all_links)}\n‚úÖ –ì–æ—Ç–æ–≤–æ"
    await msg.edit_text(log)

# ================ –û–ë–†–ê–ë–û–¢–ö–ê –ö–õ–Æ–ß–ï–ô =================
import urllib.parse

@dp.callback_query(F.data == "process")
async def process_keys(cb: types.CallbackQuery):
    config = load_settings()["SETTINGS"]
    use_white = config.getboolean("use_whitelist")
    rename = config.getboolean("rename_keys")

    links = read_lines(FILES["vless"])
    whitelist = read_lines(FILES["white"])
    ok, bad = [], []

    for l in links:
        host = urlparse(l).hostname
        if use_white and host not in whitelist:
            bad.append(l)
            continue

        if rename:
            if "#" in l:
                base, comment = l.split("#", 1)
                comment = unquote(comment)
            else:
                base, comment = l, ""

            flag_match = list(re.finditer(r'[\U0001F1E6-\U0001F1FF]{2}', comment))
            if flag_match:
                flag = flag_match[-1].group(0)
            else:
                flag = "üåê"

            country_name = country_name_from_flag(flag)
            l = f"{base}#{flag} | {country_name}"

        ok.append(l)

    write_lines(FILES["vless"], ok)
    write_lines(FILES["bad"], bad)

    text = f"""üßπ –û–±—Ä–∞–±–æ—Ç–∫–∞
–í—Å–µ–≥–æ: {len(links)}
–í bad-ipwhitelist: {len(bad)}
–û—Å—Ç–∞–ª–æ—Å—å: {len(ok)}"""
    await cb.message.answer(text)

# ================ GEO –ß–ï–ö =================

@dp.callback_query(F.data == "geo")
async def geo_check(cb: types.CallbackQuery):
    config = load_settings()["SETTINGS"]
    step = int(config.get("geo_step", 20))
    attempts = int(config.get("geo_attempts", 1))

    links = read_lines(FILES["vless"])
    unknown = [l for l in links if "#üåê | Unknown" in l]

    msg = await cb.message.answer(
        f"üåç GEO —á–µ–∫\n–ö–æ–ª-–≤–æ –ø–æ–ø—ã—Ç–æ–∫: {attempts}, —à–∞–≥: {step}\n–í—Å–µ–≥–æ: {len(links)}\nüåê | Unknown: {len(unknown)}\n–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: 0/{len(unknown)}"
    )

    for attempt in range(attempts):
        for i, l in enumerate(unknown, 1):
            host = urlparse(l).hostname
            try:
                if host_is_ip(host):
                    data = requests.get(f"http://ip-api.com/json/{host}").json()
                    cc = data.get("countryCode", "")
                    flag = chr(ord(cc[0]) + 127397) + chr(ord(cc[1]) + 127397) if cc else "üåê"
                    country_name = country_name_from_flag(flag)
                    if "#" in l:
                        base, _ = l.split("#", 1)
                        links[links.index(l)] = f"{base}#{flag} | {country_name}"
            except:
                pass

            if i % step == 0:
                unknown_now = [x for x in links if "#üåê | Unknown" in x]
                await msg.edit_text(
                    f"üåç GEO —á–µ–∫\n–ö–æ–ª-–≤–æ –ø–æ–ø—ã—Ç–æ–∫: {attempts}, —à–∞–≥: {step}\n–í—Å–µ–≥–æ: {len(links)}\nüåê | Unknown: {len(unknown_now)}\n–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ: {i}/{len(unknown)}"
                )
                await asyncio.sleep(0.1)

    write_lines(FILES["vless"], links)
    remaining = len([x for x in links if "#üåê | Unknown" in x])
    await msg.edit_text(
        f"üåç GEO –∑–∞–≤–µ—Ä—à—ë–Ω\n–í—Å–µ–≥–æ: {len(links)}\nüåê | Unknown: {remaining}\n–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç—Ä–∞–Ω—É: {remaining}"
    )

# ================ –°–¢–ê–¢–ò–°–¢–ò–ö–ê =================

@dp.callback_query(F.data == "stats")
async def stats(cb: types.CallbackQuery):
    links = read_lines(FILES["vless"])
    flags = [get_flag(l) for l in links]
    c = Counter(flags)
    final = {}
    for k, v in c.items():
        final[f"{k} | {country_name_from_flag(k)}"] = v
    sorted_final = dict(sorted(final.items(), key=lambda item: item[1], reverse=True))

    text = f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n–í—Å–µ–≥–æ –∫–ª—é—á–µ–π: {len(links)}\n"
    for k, v in sorted_final.items():
        text += f"{k} ‚Äî {v}\n"

    await cb.message.answer(text)

# ================= VLESS FILE MENU =================

@dp.callback_query(F.data == "vlessmenu")
async def vless_menu(cb: types.CallbackQuery):
    count = len(read_lines(FILES["vless"]))
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üì• –°–∫–∞—á–∞—Ç—å —Å—é–¥–∞", callback_data="download_vless")],
        [InlineKeyboardButton(text="‚òÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å –≤ GitHub", callback_data="upload_github")],
        [InlineKeyboardButton(text="‚¨Ö –ù–∞–∑–∞–¥", callback_data="back")]
    ])
    await cb.message.answer(f"üìÅ –ö–ª—é—á–µ–π: {count}", reply_markup=kb)

@dp.callback_query(F.data == "download_vless")
async def download_vless(cb: types.CallbackQuery):
    await cb.message.answer_document(FSInputFile(FILES["vless"]))

@dp.callback_query(F.data == "upload_github")
async def upload_git(cb: types.CallbackQuery):
    # –ß–∏—Ç–∞–µ–º –∫–ª—é—á–∏ –∏–∑ —Ñ–∞–π–ª–∞
    content = "\n".join(read_lines(FILES["vless"]))

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ GitHub
    REPO_FILE = "SuicideEtoExit"  # –±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è
    API_URL = f"https://api.github.com/repos/{REPO}/contents/{REPO_FILE}"
    HEADERS = {
        "Authorization": f"Bearer {GITHUB_TOKEN}",
        "Accept": "application/vnd.github+json"
    }

    # –ü–æ–ª—É—á–∞–µ–º sha —Ç–µ–∫—É—â–µ–≥–æ —Ñ–∞–π–ª–∞
    r = requests.get(API_URL, headers=HEADERS, params={"ref": "main"})
    sha = r.json().get("sha") if r.status_code == 200 else None

    # –ö–æ–¥–∏—Ä—É–µ–º –≤ Base64
    encoded_content = base64.b64encode(content.encode("utf-8")).decode("utf-8")

    payload = {
        "message": "Update VLESS keys via bot",
        "content": encoded_content,
        "branch": "main"
    }
    if sha:
        payload["sha"] = sha

    # –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞ GitHub
    resp = requests.put(API_URL, headers=HEADERS, json=payload)

    if resp.status_code in [200, 201]:
        raw_link = f"https://raw.githubusercontent.com/{REPO}/main/{REPO_FILE}"
        await cb.message.answer(f"–ö–ª—é—á–∏ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã ‚úÖ\n{raw_link}")
    else:
        await cb.message.answer(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {resp.status_code}\n{resp.text}")


# ================= –£–ü–†–ê–í–õ–ï–ù–ò–ï –°–ê–ô–¢–ê–ú–ò =================

@dp.callback_query(F.data == "sites")
async def open_sites(cb: types.CallbackQuery):
    await cb.message.answer("üìÑ –°–ø–∏—Å–æ–∫ —Å–∞–π—Ç–æ–≤", reply_markup=sites_keyboard(0))

@dp.callback_query(F.data.startswith("sites_page"))
async def sites_page(cb: types.CallbackQuery):
    try:
        page = int(cb.data.split("|")[1])
    except:
        page = 0
    await cb.message.edit_reply_markup(reply_markup=sites_keyboard(page))

@dp.callback_query(F.data.startswith("delsite"))
async def del_site(cb: types.CallbackQuery):
    try:
        index = int(cb.data.split("|")[1])
    except:
        await cb.answer("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è", show_alert=True)
        return

    sites = read_lines(FILES["sites"])
    if 0 <= index < len(sites):
        removed = sites.pop(index)
        write_lines(FILES["sites"], sites)
        await cb.answer(f"–£–¥–∞–ª–µ–Ω–æ: {removed}")
    else:
        await cb.answer("–ù–µ–≤–µ—Ä–Ω—ã–π –∏–Ω–¥–µ–∫—Å", show_alert=True)

    # –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –Ω–∞ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
    await cb.message.edit_reply_markup(reply_markup=sites_keyboard(0))


@dp.callback_query(F.data == "add_site")
async def ask_site(cb: types.CallbackQuery):
    await cb.message.answer("–û—Ç–ø—Ä–∞–≤—å URL —Å–∞–π—Ç–∞ —Ç–µ–∫—Å—Ç–æ–º")
    dp.message.register(add_site_msg)

async def add_site_msg(msg: types.Message):
    sites = read_lines(FILES["sites"])
    sites.append(msg.text.strip())
    write_lines(FILES["sites"], sites)
    await msg.answer("‚úÖ –°–∞–π—Ç –¥–æ–±–∞–≤–ª–µ–Ω", reply_markup=main_menu())

# ================= –ù–ê–°–¢–†–û–ô–ö–ò =================

# –±—É–ª–µ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
@dp.callback_query(F.data.startswith("set|"))
async def toggle_setting(cb: types.CallbackQuery):
    key = cb.data.split("|")[1]
    config = load_settings()
    
    # –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –≤ bool
    val_str = config["SETTINGS"].get(key, "False")
    val = val_str.lower() == "true"
    
    # –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
    config["SETTINGS"][key] = str(not val)
    save_settings(config)
    
    # –æ–±–Ω–æ–≤–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    await cb.message.edit_reply_markup(reply_markup=settings_keyboard())

# ================= –ò–ó–ú–ï–ù–ï–ù–ò–ï GEO =================

# ================= –ò–ó–ú–ï–ù–ï–ù–ò–ï GEO =================

from aiogram import F

# –§–ª–∞–≥ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ–≥–æ –ø–æ–ª—è
editing_geo_field = {}

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "GEO —à–∞–≥"
@dp.callback_query(F.data == "set_geo_step")
async def ask_geo_step(cb: types.CallbackQuery):
    user_id = cb.from_user.id
    editing_geo_field[user_id] = "geo_step"
    await cb.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π GEO —à–∞–≥ (—á–∏—Å–ª–æ):")
    dp.message.register(process_geo_input, lambda msg: msg.from_user.id == user_id)

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "GEO –ø–æ–≤—Ç–æ—Ä–æ–≤"
@dp.callback_query(F.data == "set_geo_attempts")
async def ask_geo_attempts(cb: types.CallbackQuery):
    user_id = cb.from_user.id
    editing_geo_field[user_id] = "geo_attempts"
    await cb.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ GEO –ø–æ–≤—Ç–æ—Ä–æ–≤ (—á–∏—Å–ª–æ):")
    dp.message.register(process_geo_input, lambda msg: msg.from_user.id == user_id)

# –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤–≤–æ–¥–∞ —á–∏—Å–ª–∞
async def process_geo_input(msg: types.Message):
    user_id = msg.from_user.id
    field = editing_geo_field.get(user_id)
    if not field:
        return

    try:
        value = int(msg.text.strip())
        config = load_settings()
        config["SETTINGS"][field] = str(value)
        save_settings(config)
        await msg.answer(f"‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ '{field}' –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ {value}", reply_markup=settings_keyboard())
    except ValueError:
        await msg.answer("‚ùå –û—à–∏–±–∫–∞: –Ω—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —á–∏—Å–ª–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        dp.message.register(process_geo_input, lambda m: m.from_user.id == user_id)

    # –æ—á–∏—Å—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    editing_geo_field.pop(user_id, None)


# ================= –°–û–•–†–ê–ù–ï–ù–ò–ï =================

@dp.callback_query(F.data == "save_settings")
async def save_set(cb: types.CallbackQuery):
    await cb.answer("‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã", show_alert=True)
# ================ –ü–ï–†–ï–ó–ê–ü–£–°–ö =================

@dp.callback_query(F.data == "restart")
async def restart(cb: types.CallbackQuery):
    subprocess.Popen(["systemctl", "restart", "vlessbot"])
    await cb.message.answer("üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫...")

# ================ –ù–ê–ó–ê–î =================

@dp.callback_query(F.data == "back")
async def back(cb: types.CallbackQuery):
    await cb.message.answer("‚ôªÔ∏è VLESS bot by ozred v0.5 üè¥‚Äç‚ò†Ô∏è ", reply_markup=main_menu())

# ================= –û–¢–ö–†–´–¢–ò–ï –ù–ê–°–¢–†–û–ï–ö =================

@dp.callback_query(F.data == "settings")
async def open_settings(cb: types.CallbackQuery):
    await cb.message.edit_text("‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞", reply_markup=settings_keyboard())

# ================ –ó–ê–ü–£–°–ö =================

if __name__ == "__main__":
    async def main():
        # —Å–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –º–µ–Ω—é –≤—Å–µ–º –∞–¥–º–∏–Ω–∞–º
        await send_menu_on_startup()
        # –∑–∞—Ç–µ–º –∑–∞–ø—É—Å–∫–∞–µ–º polling –±–æ—Ç–∞
        await dp.start_polling(bot)

    asyncio.run(main())

